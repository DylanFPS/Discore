{
    "Attachments-Within-Embeds.md": "<p>When uploading files as attachments via the <code>UploadFile</code> methods, these attachments can be used within embeds for the same message. When this is done, the attachment will not show up twice, instead it will essentially just be moved.</p>\n<p>To do this, simply pass the string <code>\"attachment://file_name.ext\"</code> to <code>DiscordEmbedBuilder.SetImage</code> where <code>file_name.ext</code> is the exact name used when calling <code>UploadFile</code>.</p>\n<p>For more information on this feature <a href=\"https://discordapp.com/developers/docs/resources/channel#using-attachments-within-embeds\">see the Discord documentation</a>.</p>\n<h2>Example</h2>\n<pre><code class=\"language-csharp\">Stream attachment = ...;\nawait textChannel.UploadFile(attachment, \"fileName.jpg\", new DiscordMessageDetails()\n    .SetEmbed(new DiscordEmbedBuilder()\n        .SetImage(\"attachment://fileName.jpg\")\n        .SetTitle(\"Embed Title\")));\n</code></pre>\n",
    "Authentication.md": "<p>Discore supports multiple methods of authenticating with the Discord API.</p>\n<h2>Authenticators</h2>\n<p>Authenticators are implemented through the <code>IDiscordAuthenticator</code> interface. These authenticators are then passed to any new <code>DiscordWebSocketApplication</code> or <code>DiscordHttpApplication</code> instances.</p>\n<h3>Bot User Token</h3>\n<p>If your application is using a bot user, its token can be used for authentication:</p>\n<pre><code class=\"language-csharp\">string token = \"bot user token goes here\";\n// Create authenticator using the bot user token method\nDiscordBotUserToken authenticator = new DiscordBotUserToken(token);\n</code></pre>\n<h3>OAuth 2 Client Credentials</h3>\n<p>To be implemented!</p>\n<h3>Username and Password</h3>\n<p>To be implemented!</p>\n",
    "Connecting-to-a-Voice-Channel.md": "<p><strong>Note:</strong> It's worth pointing out here that the voice API is only available for WebSocket applications.</p>\n<p>Each shard contains a <code>ShardVoiceManager</code> available through <code>Shard.Voice</code>. The <code>ShardVoiceManager</code> keeps track of all open voice connections to guilds that are managed by that shard.</p>\n<h2>Create a Voice Connection</h2>\n<pre><code class=\"language-csharp\">// Get the voice channel you wish to connect to.\nDiscordGuildVoiceChannel voiceChannel = ...;\n// Create the connection.\nDiscordVoiceConnection connection = shard.Voice.CreateConnection(voiceChannel);\n</code></pre>\n<p><strong>Note:</strong> If a connection to the given voice channel already exists, <code>CreateConnection</code> returns the existing connection instead of a new one being created.</p>\n<h2>Initiate the Connection</h2>\n<p>Creating a voice connection does not actually initiate the connection, this must be done manually. This is done manually to allow the application to safely subscribe to events like <code>DiscordVoiceConnection.OnConnected</code>.</p>\n<pre><code class=\"language-csharp\">await connection.ConnectAsync();\n</code></pre>\n<p>It's as easy as that! The <code>OnConnected</code> event will be fired when the handshake is finished, but during that time the voice connection is still fully usable.</p>\n<h2>Connection Invalidation</h2>\n<p>Unlike the gateway connection, voice connections do not automatically reconnect when a fatal error occurs. Therefore, when a voice connection disconnects (either normally or from an error) it is considered invalid. When this occurs the <code>OnInvalidated</code> event will be fired. You can check if a connection is invalid beforehand using the <code>IsValid</code> property.</p>\n<p>When a <code>DiscordVoiceConnection</code> is invalid, any attempt to use it will result in a no-op instead of an exception being thrown.</p>\n<p>Invalidation occurs during the following scenarios:</p><ul><li>Failed handshake</li><li>Normal disconnection</li><li>Any fatal error</li><li>Disposing of the connection</li></ul>\n<h2>Handling Errors</h2>\n<p>When a fatal error occurs within a voice connection, the <code>OnError</code> event is fired with the details. When this occurs, the Discord user will automatically be removed from the voice channel and a new <code>DiscordVoiceConnection</code> will need to be created.</p>\n<h2>Continuation</h2>\n<p>For information on how to send/receive voice data see:</p><ul><li><a href=\"./Sending-Voice-Data\">Sending Voice Data</a></li><li><a href=\"./Receiving-Voice-Data\">Receiving Voice Data</a></li></ul>\n",
    "Gateway-Caching.md": "<p>Each shard contains its own local memory cache of state of the Discord API available through <code>shard.Cache</code>. This contains lots of information not directly available through some objects, such as lists of channels in each guild.</p>\n<h3>Immutability</h3>\n<p>Every object representing state in the Discord API (e.g. <code>DiscordUser</code>, <code>DiscordGuild</code>, etc.) is immutable. To get an object representing the most up-to-date state, it must be either retrieved from the HTTP API, or pulled from cache.</p>\n<h3>Cache Structure</h3>\n<p>The cache is broken down into a tree, starting with <code>DiscoreCache</code>. Any object in the Discord API that contains nested data, for example a guild, has its own cache (e.g. <code>DiscoreGuildCache</code>). These \"nested caches\" contain a <code>Value</code> property which will return the most up-to-date state for the object it represents, as well as other properties for the data of any nested objects.</p>\n<h3>Cache Clearing</h3>\n<p>The cache is cleared in two scenarios to avoid stale and/or non-updateable data from being available:</p><ul><li>Manually stopping a shard.</li><li>If the shard's gateway connection starts a new session.</li></ul>\n<p>If the cache is cleared automatically, for example due to a new gateway session, the cache will be repopulated immediately with up-to-date data.</p>\n<h3>Example: Message Handling</h3>\n<pre><code class=\"language-csharp\">shard.Gateway.OnMessageCreated += Gateway_OnMessageCreated;\n\n...\n\nprivate static void Gateway_OnMessageCreated(object sender, MessageEventArgs e)\n{\n    DiscordMessage message = e.Message;\n    DiscoreCache cache = e.Shard.Cache;\n\n    // Get the text channel the message was sent in, from cache and expect it to be a guild channel.\n    DiscordGuildTextChannel guildTextChannel = cache.Channels.Get(message.ChannelId) as DiscordGuildTextChannel;\n    if (guildTextChannel != null)\n    {\n        // Get the cache of the guild the channel is in.\n        DiscoreGuildCache guildCache = cache.Guilds.Get(guildTextChannel.GuildId);\n\n        // Get current state of guild.\n        DiscordGuild guild = guildCache.Value;\n\n        ...    \n    }\n    else { /* Message was sent from a DM. */}\n}\n</code></pre>\n",
    "Home.md": "<h2>Getting Started</h2>\n<h3>1. Acquire Discore</h3>\n<h4>Pre-built Downloads</h4>\n<p><a href=\"https://www.nuget.org/packages/Discore/\">Pre-built releases can be downloaded via NuGet here.</a></p>\n<h4>Compile from Source</h4>\n<p>The project can be built with <a href=\"https://www.visualstudio.com/downloads/\">Visual Studio 2017</a> (e.g. via the \".NET Core 1.0 - 1.1 development tools\").</p>\n<h3>2. Choose your type of Discord application</h3>\n<p>Applications using Discore are not required to use all three of the APIs. Instead, applcations only need to use the APIs they need as well as the dependencies of those APIs. For example: applications that just need the HTTP API require nothing else, while applications using the voice API require a Gateway connection, and a Gateway connection requires the HTTP API:</p>\n<p>HTTP &lt; Gateway &lt; Voice</p><ul><li><a href=\"./WebSocket-Applications\">Voice or Gateway usage</a>.</li><li><a href=\"./HTTP-Applications\">HTTP only</a>.</li></ul>\n<h2>Example Bot: Ping Pong</h2>\n<p>If you wish to test your Discore installation, try this example bot. Just enter your bot's user token for the <code>token</code> variable and fire away!</p>\n<pre><code class=\"language-csharp\">using Discore;\nusing Discore.Http;\nusing Discore.WebSocket;\nusing System.Threading.Tasks;\n\nnamespace DiscorePingPong\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            Program program = new Program();\n            program.Run().Wait();\n        }\n\n        public async Task Run()\n        {\n            // Create authenticator using a bot user token.\n            DiscordBotUserToken token = new DiscordBotUserToken(\"&lt;bot user token goes here&gt;\");\n\n            // Create a WebSocket application.\n            DiscordWebSocketApplication app = new DiscordWebSocketApplication(token);\n\n            // Create and start a single shard.\n            Shard shard = app.ShardManager.CreateSingleShard();\n            await shard.StartAsync();\n\n            // Subscribe to the message creation event.\n            shard.Gateway.OnMessageCreated += Gateway_OnMessageCreated;\n\n            // Wait for the shard to end before closing the program.\n            while (shard.IsRunning)\n                await Task.Delay(1000);\n        }\n\n        private static async void Gateway_OnMessageCreated(object sender, MessageEventArgs e)\n        {\n            Shard shard = e.Shard;\n            DiscordMessage message = e.Message;\n\n            if (message.Author == shard.User)\n                // Ignore messages created by our bot.\n                return;\n\n            if (message.Content == \"!ping\")\n            {\n                // Grab the DM or guild text channel this message was posted in from cache.\n                ITextChannel textChannel = (ITextChannel)shard.Cache.Channels.Get(message.ChannelId);\n\n                try\n                {\n                    // Reply to the user who posted \"!ping\".\n                    await textChannel.CreateMessage($\"&lt;@!{message.Author.Id}&gt; Pong!\");\n                }\n                catch (DiscordHttpApiException) { /* Message failed to send... :( */ }\n            }\n        }\n    }\n}\n</code></pre>\n",
    "HTTP-Applications.md": "<p>If your Discord application does not require realtime interaction with the Discord API or does not have a bot user, Discore can be used as a simple interface with the Discord HTTP API.</p>\n<p>To use Discore for just HTTP API usage, simply:</p>\n<pre><code class=\"language-csharp\">// Create an HTTP application\nDiscordHttpApplication app = new DiscordHttpApplication(authenticator);\n// Get the Discord HTTP API interface for the Discord application specified above\nDiscordHttpApi httpApi = app.HttpApi;\n</code></pre>\n<p>For creating the <code>authenticator</code>, see the <a href=\"./Authentication\">authentication documentation</a>.</p>\n<h2>HTTP API Configuration</h2>\n<p><code>DiscordHttpApplication</code> and <code>DiscordWebSocketApplication</code> both optionally take an <code>InitialHttpApiSettings</code> argument. <code>InitialHttpApiSettings</code> lets you change the way Discore works with the Discord HTTP API.</p>\n<h3>Options In <code>InitialHttpApiSettings</code></h3>\n<h4><code>RetryWhenRateLimited</code></h4>\n<p>Default: <code>true</code>.\nSets whether rate limited requests should be resent. Additionally, this can be changed after an application is created by setting <code>DiscordHttpApi.RetryWhenRateLimited</code>.</p>\n<h4><code>RateLimitHandlingMethod</code></h4>\n<p>Default: <code>RateLimitHandlingMethod.Throttle</code>.\nSets how rate limits should be handled locally, options are:</p><ul><li><code>Throttle</code>: Prevents being rate limited by placing requests into a queue and only sending them out when it is safe. Avoids 429's 99% of the time. <strong>Note</strong>: the queue is per rate-limited route, instead of effecting every type of request globally.</li><li><code>Minimal</code>: Doesn't try to control requests, but forces requests to wait after a 429 is received.</li></ul>\n<h4><code>UseSingleHttpClient</code></h4>\n<p>Default: <code>true</code>.\nSets whether a single <code>HttpClient</code> should be used for all HTTP API requests, or if a new one should be created for each request. In rare cases, using a single <code>HttpClient</code> causes some requests to never send and end up with the task being cancelled after the <code>HttpClient</code>'s timeout time passes. We believe this is a .NET Core bug, as it seems to be operating system specific.</p>\n<h2>HTTP API Interface</h2>\n<p>The <code>DiscordHttpApi</code> object provided from either a <code>DiscordHttpApplication</code> or a <code>DiscordWebSocketApplication</code> provides a simple interface with the Discord API that matches the way the HTTP API was broken down in <a href=\"https://discordapp.com/developers/docs/intro\">Discord's API documentation</a> (referring to the \"resources\" section).</p>\n<p>For example, to get a user:</p>\n<pre><code class=\"language-csharp\">DiscordHttpApi httpApi = app.HttpApi;\n// User HTTP endpoints are specified under the \"User\" section in the Discord documentation\nDiscordUser user = await httpApi.Users.Get(userId);\n</code></pre>\n<h2>Handling API Errors</h2>\n<p>If a request happens to trigger an API error, a <code>DiscordHttpApiException</code> will be thrown from the interface method. This exception contains the Discord HTTP API error code, as well as the HTTP status code associated with the response.</p>\n<p>Example usage:</p>\n<pre><code class=\"language-csharp\">try\n{\n    DiscordUser user = await httpApi.Users.Get(userId);\n}\ncatch (DiscordHttpApiException apiEx)\n{\n    if (apiEx.ErrorCode == DiscordHttpErrorCode.UnknownUser)\n    {\n        // The user we are looking for does not exist :(\n    }\n}\n</code></pre>\n",
    "Logging.md": "<p>Since Discore consists of many isolated internal tasks, a logging system was created to keep track of everything happening. While the Discore logger is not required to be used in an application, it may assist with:</p><ul><li><strong>Tracking down bugs occurring in Discore</strong>: If you suspect a bug is originating from Discore and not your application, these logs should be very useful in determining what is happening.</li><li><strong>Extending your own logging system</strong>: It may be useful to include events occurring internally in Discore to help keep track of what your application is doing.</li></ul>\n<h2>Hooking Into The Logger</h2>\n<p>Every time a message is logged in Discore, the event <code>DiscoreLogger.OnLog</code> is fired.</p>\n<p>This event is fired with a few details:</p><ul><li>The <code>DiscoreLogger</code> that fired the event (available through the <code>sender</code> parameter).</li><li>The message that was logged.</li><li>The type of message.</li><li>The <code>DateTime</code> the message was logged.</li></ul>\n<h2>Log Types</h2>\n<p>Discore breaks down message logs into four types:</p><ul><li>Verbose (e.g. connection handshakes)</li><li>Info (e.g. important events such as a gateway re-connection)</li><li>Warning (e.g. unexpected non-fatal events)</li><li>Error (e.g. fatal events such as abnormal socket disconnections)</li></ul>\n<h2>Filtering</h2>\n<p>Log messages can be disabled at a global level via <code>DiscoreLogger.MinimumLevel</code>. Unless Discore is compiled with the DEBUG preprocessor, this defaults to <code>DiscoreLogType.Info</code> (otherwise <code>DiscoreLogType.Verbose</code>). Verbose messages are filtered out by default for performance reasons. For example, a bot that has voice chat support serving hundreds of guilds does not need the verbose messages created from voice sockets connecting and disconnecting constantly.</p>\n<h2>Extending The Logger</h2>\n<p>If you wish to use the Discore logger as your application's logger, a <code>DiscoreLogger</code> can be created with a prefix. Each logger is meant for a certain area of the application, with the prefix being a short description of that area.</p>\n<p>This example creates a new logger to be used in the message handling procedure of an application:</p>\n<pre><code class=\"language-csharp\">DiscoreLogger customLogger = new DiscoreLogger(\"Message Handling\");\ncustomLogger.LogInfo(\"Hello!\"); // This would generate the message \"[Message Handling] Hello!\"\n</code></pre>\n",
    "Permission-Checking.md": "<p>Discore provides a helper class for calculating whether a user has a certain permission. This is available through <code>DiscordPermissionHelper</code>.</p>\n<h3>Example: <code>!delete</code> Command</h3>\n<p>If you are creating a public bot, this can be used for example to prevent users without the <code>ManageMessages</code> permission from using a bot command that can mass-delete messages.</p>\n<pre><code class=\"language-csharp\">private static void Gateway_OnMessageCreated(object sender, MessageEventArgs e)\n{\n    DiscordMessage message = e.Message;\n    DiscoreCache cache = e.Shard.Cache;\n\n    // Get the text channel the message was sent in, from cache and expect it to be a guild channel.\n    DiscordGuildTextChannel guildTextChannel = cache.Channels.Get(message.ChannelId) as DiscordGuildTextChannel;\n    if (guildTextChannel != null)\n    {\n        // Get the cache of the guild the channel is in.\n        DiscoreGuildCache guildCache = cache.Guilds.Get(guildTextChannel.GuildId);\n\n        // Get the cache of the member who sent this message.\n        DiscoreMemberCache memberCache = guildCache.Members.Get(message.Author.Id);\n\n        // Note: You will most likely want to check if guildCache and memberCache were retrieved successfully.\n\n        if (message.Content.StartsWith(\"!delete\"))\n        {\n            // Check if this user has permission to use this command in this channel.\n            if (DiscordPermissionHelper.HasPermission(DiscordPermission.ManageMessages, memberCache.Value, guildCache.Value, guildTextChannel))\n            {\n                // Handle !delete command...\n            }\n        }\n    }\n}\n</code></pre>\n<p>For information on how to subscribe to this event, <a href=\"./Sharding#gateway-interaction\">see the sharding documentation</a>.</p>\n",
    "Receiving-Voice-Data.md": "<p>To be implemented soon...</p>\n<p>Feel free to open an issue if this is an important requirement of your project, we would be happy to re-prioritize things!</p>\n",
    "Sending-Voice-Data.md": "<h2>Setup</h2>\n<h3>Data Requirements</h3>\n<p>When sending voice data to Discord, the data must be in <a href=\"https://en.wikipedia.org/wiki/Pulse-code_modulation\">PCM form</a>. A good tool that can convert many audio formats to PCM is <a href=\"https://ffmpeg.org/\">ffmpeg</a>.</p>\n<h3>Speaking State</h3>\n<p>Before voice data can be sent, the speaking state of the voice connection must be <code>true</code>. This will cause the user to appear as speaking. When voice data is finished being sent, this can be set back to <code>false</code> to indicate it's done.</p>\n<p>This is set through the <code>DiscordVoiceConnection.SetSpeakingAsync</code> method and can be checked through the <code>IsSpeaking</code> property:</p>\n<pre><code class=\"language-csharp\">// Assume variable voice is our connection.\nDiscordVoiceConnection voice = ...;\n\n// Set speaking if not already\nif (!voice.IsSpeaking)\n    await voice.SetSpeakingAsync(true);\n</code></pre>\n<h2>Sending Voice Data</h2>\n<p>Sending voice data in Discore is fairly simple. <code>DiscordVoiceConnection</code> contains two methods for this, <code>SendVoiceData</code> and <code>CanSendVoiceData</code>. Instead of using a blocking stream to send the data, we allow the application to create their own system for sending data to the voice buffer in <code>DiscordVoiceConnection</code>.</p>\n<p><code>CanSendVoiceData</code> takes a byte amount and returns whether there is enough room in the voice data to send that amount of data. <code>SendVoiceData</code> can then be used to send the actual data.</p>\n<p>The size of each voice data block sent to the connection should be at max <code>DiscordVoiceConnection.PCM_BLOCK_SIZE</code>. Anything bigger can result in the audio playing faster than intended and/or introduce other audio artifacts. Sending smaller blocks can also create artifacts, but this is not always avoidable.</p>\n<p>An example send-loop is <a href=\"#send-loop-example\">available below</a>.</p>\n<h2>Manipulating the Voice Buffer</h2>\n<h3>Getting Unsent Data and Clearing</h3>\n<p>The number of bytes that still need to be sent out to Discord can be retrieved with the <code>BytesToSend</code> property. If the application needs this buffer to be clear, the <code>ClearVoiceBuffer</code> method can be called to cancel any queued data.</p>\n<pre><code class=\"language-csharp\">// Assume variable voice is our connection.\nDiscordVoiceConnection voice = ...;\n\n// Ensure voice buffer is empty.\nif (voice.BytesToSend &gt; 0)\n    voice.ClearVoiceBuffer();\n</code></pre>\n<h3>Pausing/Resuming</h3>\n<p>The underlying loop of sending this queued data can also be paused if necessary with the <code>IsPaused</code> property.</p>\n<h2>Send-Loop Example</h2>\n<p>A simple send-loop example could be implemented as follows:</p>\n<pre><code class=\"language-csharp\">// Assume variable voice is our connection.\nDiscordVoiceConnection voice = ...;\n\n// Create a buffer for moving data from the source to the voice connection.\nbyte[] transferBuffer = new byte[DiscordVoiceConnection.PCM_BLOCK_SIZE];\n\nwhile (sendingVoiceData &amp;&amp; voice.IsValid)\n{\n    // Check if there is room in the voice buffer\n    if (voice.CanSendVoiceData(transferBuffer.Length))\n    {\n        // Read some voice data into our transfer buffer.\n        int read = source.Read(transferBuffer, 0, transferBuffer.Length);\n        // Send the data we read from the source into the voice buffer.\n        voice.SendVoiceData(transferBuffer, 0, read);\n    }\n    else\n        // Sleep for at least 1ms to avoid burning CPU cycles.\n        Thread.Sleep(1);\n}\n</code></pre>\n<p>See the <a href=\"./Connecting-to-a-Voice-Channel\">connecting documentation</a> for information on how to create the <code>DiscordVoiceConnection</code>.</p>\n",
    "Sharding.md": "<p>In order to work with any WebSocket connection in Discore, a shard is required. If you are working on a public Discord bot, eventually you will need to create multiple shards.</p>\n<p>For information on how sharding works with the Discord API, <a href=\"https://discordapp.com/developers/docs/topics/gateway#sharding\">see Discord's documentation</a>.</p>\n<h2>Sharding Methods</h2>\n<h3>Single Shard Applications</h3>\n<p>If you know your application only requires a single shard or you are testing things, Discore can create and manage a single shard:</p>\n<pre><code class=\"language-csharp\">Shard shard = app.ShardManager.CreateSingleShard();\nawait shard.StartAsync();\n</code></pre>\n<h3>Automatic Minimum Shards</h3>\n<p>If you are not sure how many shards your application will require or want this to be handled automatically, Discore can query the Discord API and create the minimum number of required shards for your application:</p>\n<pre><code class=\"language-csharp\">await app.ShardManager.CreateMinimumRequiredShardsAsync();\nawait Task.WhenAll(app.ShardManager.StartShardsAsync());\n</code></pre>\n<h3>A Set Of Shards</h3>\n<p>The Discore <code>ShardManager</code> can be used to manage any number of specific shards, rather than all of them. This can be very useful for example if your application creates a new process for each shard.</p>\n<pre><code class=\"language-csharp\">// For this example we will use a bot that requires 6 shards.\nint totalShards = 6;\n\n// However, this process will only handle the first 3.\nint[] shardIds = new int[] { 0, 1, 2 };\n\n// Create and start the 3 shards.\napp.ShardManager.CreateShards(shardIds, totalShards);\nawait Task.WhenAll(app.ShardManager.StartShardsAsync());\n</code></pre>\n<p>If your application needs to automatically get the number of required shards for your application, the HTTP implementation provides a method for this:</p>\n<pre><code class=\"language-csharp\">int requiredShards = await app.HttpApi.Gateway.GetBotRequiredShards();\n</code></pre>\n<h2>Gateway Interaction</h2>\n<p>Each shard instance manages a separate connection to the Discord Gateway API. This is available through <code>shard.Gateway</code>. This interface provides events for Discord gateway events, as well as methods for interacting directly with it such as updating a bot user's status.</p>\n<pre><code class=\"language-csharp\">shard.Gateway.OnMessageCreated += Gateway_OnMessageCreated;\n\n...\n\nprivate static void Gateway_OnMessageCreated(object sender, MessageEventArgs e)\n{\n    // Someone sent a message somewhere...\n}\n</code></pre>\n<h2>Voice Connections</h2>\n<p>Each shard contains a <code>ShardVoiceManager</code> available through <code>Shard.Voice</code>. Please <a href=\"./Voice-Prerequisites\">see the main voice documentation here</a> for more information.</p>\n<h2>Handling Shard Errors</h2>\n<p>For any non-fatal error a shard's gateway connection encounters, the shard will automatically seamlessly reconnect. However, in the event a shard does encounter a fatal error, the <code>Shard.OnFailure</code> event will be fired.</p>\n<p>An example of a shard failure is when the gateway fails to authenticate:</p>\n<pre><code class=\"language-csharp\">shard.OnFailure += Shard_OnFailure;\n\n...\n\nprivate static void Shard_OnFailure(object sender, ShardFailureEventArgs e)\n{\n    if (e.Reason == ShardFailureReason.AuthenticationFailed)\n    {\n        // At this point, the entire DiscordWebSocketApplication will most likely need\n        // the correct authentication and then be restarted completely... :(\n    }\n}\n</code></pre>\n<h2>Automatic Shard Reconnections</h2>\n<p>In the event a shard does automatically reconnect internally, the <code>Shard.OnReconnected</code> event will be fired. This is important to implement, because some state on your application may be lost, for example the user status.</p>\n<pre><code class=\"language-csharp\">shard.OnReconnected += Shard_OnReconnected;\n\n...\n\nprivate static async void Shard_OnReconnected(object sender, ShardEventArgs e)\n{\n    await e.Shard.Gateway.UpdateStatusAsync(\"I'm a robot!\");\n}\n</code></pre>\n",
    "Updating-Messages.md": "<p>Since the Discord API only sends partial versions of messages on a message update event, Discore provides a way to take an older version of a message and combine it with the newer partial.</p>\n<p>Discore does not cache messages locally, so in order to do this effectively the application will need to store them manually. For the sake of example, lets say messages for a particular channel are saved in a dictionary:</p>\n<pre><code class=\"language-csharp\">ConcurrentDictionary&lt;Snowflake, DiscordMessage&gt; messages = ...;\n\n...\n\n// Subscribe to message creation event.\nshard.Gateway.OnMessageCreated += Gateway_OnMessageCreated;\n\n...\n\nprivate static async void Gateway_OnMessageCreated(object sender, MessageEventArgs e)\n{\n     // Add each new message to the dictionary.\n     messages.TryAdd(e.Message.Id, e.Message);\n}\n</code></pre>\n<p>Now when we receive a partial message from the message update event, we can take the older version from the dictionary and combine them to get the full updated message:</p>\n<pre><code class=\"language-csharp\">// Subscribe to message update event.\nshard.Gateway.OnMessageUpdated += Gateway_OnMessageUpdated;\n\n...\n\nprivate void Gateway_OnMessageUpdated(object sender, MessageUpdateEventArgs e)\n{\n    // Get the old and new partial messages.\n    DiscordMessage oldMessage = messages[e.PartialMessage.Id];\n    DiscordMessage newPartialMessage = e.PartialMessage;\n\n    // Create a new message object by combining the old message with the newer partial.\n    // Note: oldMessage and newPartialMessage are not changed by this.\n    DiscordMessage newFullMessage = DiscordMessage.Update(oldMessage, newPartialMessage);\n\n    // Update the message cache.\n    messages[newFullMessage.Id] = newFullMessage;\n}\n</code></pre>\n",
    "Voice-Prerequisites.md": "<p>In order to send/receive voice data through Discore, two external libraries are needed; <a href=\"https://download.libsodium.org/doc/\">libsodium</a> and <a href=\"http://opus-codec.org/\">opus</a>.</p>\n<p>Discore expects the libsodium and opus binaries to be named <code>libsodium</code> and <code>opus</code> respectively with the OS specific extension and/or prefix. For example, on Windows the binaries would need to be named <code>libsodium.dll</code> and <code>opus.dll</code>.</p>\n<h2>Adding to Visual Studio 2017 Projects</h2>\n<p><strong>Note:</strong> This is only necessary if <code>libsodium</code> or <code>opus</code> are not available globally on the target system.</p>\n<p>Assuming this is a .NET Core project, the binaries need to be dropped in the same directory as the <code>.csproj</code>. When publishing the project, the binaries need to be in the same directory as the application binary.</p>\n<h2>Pre-Compiled Windows Binaries</h2>\n<p>If your application is targeting Windows, the Discore repository contains tested pre-compiled 32 and 64-bit binaries <a href=\"https://github.com/BundledSticksInkorperated/Discore/tree/master/lib/windows\">which can be downloaded here</a>.</p>\n<h2>Using the Discore Voice API</h2>\n<p>Once everything is all setup, please see <a href=\"./Connecting-to-a-Voice-Channel\">the documentation on how to use the voice API here</a>.</p>\n",
    "WebSocket-Applications.md": "<p>WebSocket applications are meant for realtime interactions with the Discore API, such as a bot user. Using Discore for WebSocket use will give your application access to Discord's Gateway API.</p>\n<p>To use Discore for a WebSocket application is very simple:</p>\n<pre><code class=\"language-csharp\">// Create the WebSocket application wrapper\nusing (DiscordWebSocketApplication app = new DiscordWebSocketApplication(authenticator))\n{\n    ...\n}\n</code></pre>\n<p>For creating the <code>authenticator</code>, see the <a href=\"./Authentication\">authentication documentation</a>.</p>\n<h2>Connecting to the Gateway API</h2>\n<p><code>DiscordWebSocketApplication</code> provides a <code>ShardManager</code> to create connections with the Gateway API. This can be accessed through <code>DiscordWebSocketApplication.ShardManager</code>.</p>\n<p>To make a single connection to the Gateway API:</p>\n<pre><code class=\"language-csharp\">// Create a single shard for our application.\nShard shard = app.ShardManager.CreateSingleShard(); // assuming app is a DiscordWebSocketApplication\n// Start the shard, which will initiate the Gateway connection.\nawait shard.StartAsync(CancellationToken.None);\n</code></pre>\n<p>For more information on using shards and the Gateway API, <a href=\"./Sharding\">see the main documentation</a>.</p>\n<h2>HTTP API Usage</h2>\n<p>Even though we have not created a <code>DiscordHttpApplication</code>, the HTTP API can still be accessed through <code>DiscordWebSocketApplication.HttpApi</code>:</p>\n<pre><code class=\"language-csharp\">DiscordHttpApi httpApi = app.HttpApi; // assuming app is a DiscordWebSocketApplication\n</code></pre>\n<p>See the main HTTP API documentation <a href=\"./HTTP-Applications#http-api-interface\">here</a>.</p>\n",
    "_Footer.md": "<p>&copy; 2017 Bundled Sticks</p>\n",
    "_Sidebar.md": "<p><a href=\"./Home\">Home</a></p>\n<h3>WebSocket</h3><ul><li><a href=\"./WebSocket-Applications\">Getting Started</a></li><li><a href=\"./Sharding\">Sharding</a></li><li><a href=\"./Gateway-Caching\">Caching</a></li></ul>\n<h3>Voice</h3><ul><li><a href=\"./Voice-Prerequisites\">Getting Started</a></li><li><a href=\"./Connecting-to-a-Voice-Channel\">Connecting</a></li><li><a href=\"./Sending-Voice-Data\">Sending Data</a></li><li><a href=\"./Receiving-Voice-Data\">Receiving Data</a></li></ul>\n<h3>HTTP</h3><ul><li><a href=\"./HTTP-Applications\">Getting Started</a></li><li><a href=\"./HTTP-Applications#http-api-interface\">Interface Usage</a></li></ul>\n<h3>Miscellaneous</h3><ul><li><a href=\"./Authentication\">Authentication</a></li><li><a href=\"./Permission-Checking\">Permission Checking</a></li><li><a href=\"./Updating-Messages\">Updating Messages</a></li><li><a href=\"./Attachments-Within-Embeds\">Attachments in Embeds</a></li><li><a href=\"./Logging\">Logging</a></li></ul>\n"
}